# -*- coding: utf-8 -*-
"""Quantum_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mLWR2higJFwAWW4pExD0mZ94et9p1O7z
"""

!pip install rasterio
!pip install geopandas

# Commented out IPython magic to ensure Python compatibility.
import os

import rasterio
from rasterio.plot import reshape_as_image
import rasterio.mask
from rasterio.features import rasterize

import pandas as pd
import geopandas as gpd
from shapely.geometry import mapping, Point, Polygon
from shapely.ops import cascaded_union

import numpy as np
import cv2
import matplotlib.pyplot as plt

# %matplotlib inline

import rasterio
import geopandas as gpd

# Read in the Sentinel2 image
raster_path = '/content/T36UXV_20200406T083559_TCI_10m.jp2'
with rasterio.open(raster_path, "r", driver="JP2OpenJPEG") as src:
    raster_img = src.read()
    raster_meta = src.meta

src.meta

# Read in the mask file
mask_path = '/content/Masks_T36UXV_20190427.shp'
df_mask = gpd.read_file(mask_path)
df_mask.sample(5)

df_mask.info()

df_mask.shape

print(df_mask.isnull().sum())

df_mask = df_mask[df_mask.geometry.notnull()]

df_mask.shape

print(raster_img.shape)

raster_img = reshape_as_image(raster_img)

print(raster_img.shape)

plt.figure(figsize=(15,15))
plt.imshow(raster_img);

#Checking coordinates of polygon using Polygon methods
df_mask['geometry'][0].exterior.coords.xy

# cut fields from Raster

src = rasterio.open(raster_path, 'r')
failed = []
for num, row in df_mask.iterrows():
    try:
        masked_image, out_transform = rasterio.mask.mask(src, [mapping(row['geometry'])], crop=True, nodata=0)
    except:
        failed.append(num)
print("Rasterio failed to mask {} files".format(len(failed)))

# Converting GeoDataframe to raster CRS

# assigning crs
df_mask.crs = {'init' :'epsg:4324'}

#transforming polygons to the raster crs
df_mask = df_mask.to_crs({'init' : raster_meta['crs']['init']})



#out_image, out_transform = rasterio.mask.mask(src, mask.geometry, crop=True)
#raster_img = out_image.astype(np.float32)



from sklearn.model_selection import train_test_split

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(raster_img, df_mask, test_size=0.2, random_state=42)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense

# Create the CNN model
model = Sequential()
model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=X_train[0].shape))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
history = model.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))

# Evaluate the model
test_loss, test_acc = model.evaluate(X_test, y_test, verbose=2)
print('Test accuracy:', test_acc)



"""Here are some proposals that could potentially help to improve the effectiveness of soil erosion detection models:

Including temporal information: Soil erosion is a dynamic process that can vary over time. Including temporal information such as historical erosion data, time-series satellite imagery, and weather data can help to capture the temporal changes and improve the accuracy of the model.

Incorporating multi-source data: Soil erosion is a complex phenomenon and can be influenced by various factors. Incorporating data from different sources such as remote sensing, weather stations, and soil moisture sensors can improve the accuracy of the model

As for Python:

Tuning hyperparameters: Hyperparameters such as learning rate, batch size, and number of epochs can significantly affect the model's performance. Using techniques such as grid search or random search to find the optimal hyperparameters can improve the model's accuracy. The GridSearchCV class from the sklearn.model_selection module can be used for hyperparameter tuning.

Using a different loss function: The binary cross-entropy loss function is commonly used for binary classification problems such as soil erosion detection. However, using a different loss function such as focal loss can improve the model's performance. These loss functions are available in the tensorflow_addons package.

"""